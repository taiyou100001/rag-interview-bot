[
  {
    "id": "Q001",
    "職位": "後端工程師",
    "題目": "請描述你對資料庫索引的理解，並舉例實際應用。",
    "類型": "專業題",
    "關鍵詞": ["資料庫", "索引", "SQL", "效能優化"],
    "標準答案": "資料庫索引是一種加速查詢的資料結構......（略）",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q002",
    "職位": "後端工程師",
    "題目": "描述 *args 和 **kwargs 的差異。",
    "類型": "專業題",
    "關鍵詞": ["Python", "*args", "**kwargs", "參數"],
    "標準答案": "*args 代表可變位置參數，用來傳入不定數量的位置參數；**kwargs 則代表可變關鍵字參數，用來傳入不定數量的鍵值對參數。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q003",
    "職位": "後端工程師",
    "題目": "Python 中，如何使用 decorator？",
    "類型": "專業題",
    "關鍵詞": ["Python", "decorator", "裝飾器", "函式"],
    "標準答案": "Decorator 是一種用來擴充原本函式功能的語法糖，常用 @ 符號實作，將一個函式包裝後再傳回。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q004",
    "職位": "後端工程師",
    "題目": "什麼是繼承？",
    "類型": "專業題",
    "關鍵詞": ["Python", "OOP", "繼承", "物件導向"],
    "標準答案": "繼承是物件導向程式設計中的一種概念，允許子類別繼承父類別的屬性和方法，提高程式的重用性。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q005",
    "職位": "後端工程師",
    "題目": "什麼是 PEP8？",
    "類型": "專業題",
    "關鍵詞": ["Python", "PEP8", "編碼風格", "標準"],
    "標準答案": "PEP8 是 Python 官方建議的編碼風格指南，旨在提高 Python 程式碼的可讀性與一致性。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q006",
    "職位": "後端工程師",
    "題目": "remove 和 del 差別？",
    "類型": "專業題",
    "關鍵詞": ["Python", "remove", "del", "list 操作"],
    "標準答案": "remove 是用來移除 list 中第一個出現的指定值；del 是根據索引刪除指定位置的元素，也可用來刪除變數。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q007",
    "職位": "後端工程師",
    "題目": "list 和 tuple 差別？",
    "類型": "專業題",
    "關鍵詞": ["Python", "list", "tuple", "資料結構"],
    "標準答案": "list 是可變動的資料結構，tuple 則是不可變動的；tuple 通常用於不可更動的資料或當作 dictionary key。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q008",
    "職位": "後端工程師",
    "題目": "什麼是 slicing？適用於哪種資料型態？",
    "類型": "專業題",
    "關鍵詞": ["Python", "slicing", "切片", "序列"],
    "標準答案": "Slicing 是用來取出序列資料子集的語法，可應用於 list、tuple、string 等資料型態，語法為 [start:stop:step]。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q009",
    "職位": "後端工程師",
    "題目": "簡述 Python 中 raise, as, continue, pass, break 的作用。",
    "類型": "專業題",
    "關鍵詞": ["Python", "控制語句", "raise", "pass", "break", "continue"],
    "標準答案": "raise 用於觸發例外；as 多用於例外處理與別名；continue 跳過當次迴圈；pass 代表空語句；break 跳出整個迴圈。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q010",
    "職位": "後端工程師",
    "題目": "在 Python 中如何使用 async？",
    "類型": "專業題",
    "關鍵詞": ["Python", "async", "非同步", "協程"],
    "標準答案": "使用 async 定義非同步函式，配合 await 呼叫協程；通常與 asyncio 模組搭配，用來實作非同步 I/O 任務。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q011",
    "職位": "後端工程師",
    "題目": "Python 和 Java 的差異？",
    "類型": "專業題",
    "關鍵詞": ["Python", "Java", "語言比較", "編譯", "語法"],
    "標準答案": "Python 是直譯式、動態型別語言，語法簡潔；Java 為編譯式、靜態型別語言，需先編譯成 bytecode 再執行於 JVM。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q012",
    "職位": "後端工程師",
    "題目": "Deep copy 和 shallow copy 的差異？",
    "類型": "專業題",
    "關鍵詞": ["Python", "deep copy", "shallow copy", "複製"],
    "標準答案": "shallow copy 複製物件但共享內部可變資料的參考；deep copy 則是完全複製所有層級資料，兩者互不影響。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q013",
    "職位": "後端工程師",
    "題目": "相較於 Java，為什麼 Python 較不擅長處理並行任務？",
    "類型": "專業題",
    "關鍵詞": ["Python", "Java", "並行", "GIL", "多執行緒"],
    "標準答案": "Python 的 GIL（Global Interpreter Lock）限制同一時間只能執行一個執行緒，影響多執行緒效能，而 Java 使用原生多執行緒處理較優。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q014",
    "職位": "後端工程師",
    "題目": "通常應用程式要跑 Django 時會用什麼當基底？",
    "類型": "專業題",
    "關鍵詞": ["Django", "WSGI", "Gunicorn", "Web Server"],
    "標準答案": "部署 Django 應用時，通常會以 WSGI server（如 Gunicorn 或 uWSGI）作為基底，再搭配反向代理伺服器（如 Nginx）運行。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q015",
    "職位": "後端工程師",
    "題目": "若要處理同時進來的 request 要怎麼有效處理？",
    "類型": "專業題",
    "關鍵詞": ["並發", "非同步", "多執行緒", "負載平衡"],
    "標準答案": "可使用非同步程式設計（async/await）、多執行緒/多行程、Queue、或搭配負載平衡器（如 Nginx）有效分散並行請求的負擔。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q016",
    "職位": "後端工程師",
    "題目": "如何處理 BFF 問題？",
    "類型": "專業題",
    "關鍵詞": ["BFF", "Backend for Frontend", "API Gateway", "設計模式"],
    "標準答案": "可建立針對特定前端的 API 層（BFF），實作簡化的介面，過濾後端複雜邏輯，或使用 API Gateway 模式將邏輯集中管理。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q017",
    "職位": "後端工程師",
    "題目": "什麼是並發性？",
    "類型": "專業題",
    "關鍵詞": ["並發", "Concurrency", "多執行緒", "非同步"],
    "標準答案": "並發性指的是在同一時間段內，同時處理多個任務的能力，透過非同步、協程、多執行緒等技術實現，提高效能。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q018",
    "職位": "後端工程師",
    "題目": "簡述什麼是 cache？",
    "類型": "專業題",
    "關鍵詞": ["Cache", "快取", "記憶體", "效能優化"],
    "標準答案": "Cache 是暫存資料以加速讀取的一種技術，通常儲存在記憶體中，避免重複計算或頻繁存取資料來源，提高效能。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q019",
    "職位": "後端工程師",
    "題目": "什麼是 CPU 和 Memory tuning？",
    "類型": "專業題",
    "關鍵詞": ["效能調校", "CPU 使用率", "記憶體管理", "監控"],
    "標準答案": "CPU 和 Memory tuning 是指透過資源監控、程式優化、GC 調整、非同步處理等方式，降低 CPU 負載與記憶體消耗，提升系統穩定性與效率。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q020",
    "職位": "後端工程師",
    "題目": "如果 RabbitMQ 的 task 執行失敗，應該如何處理？",
    "類型": "專業題",
    "關鍵詞": ["RabbitMQ", "Message Queue", "錯誤處理", "retry"],
    "標準答案": "可設定 retry 機制、dead-letter queue（死信佇列）、log 記錄失敗任務，並搭配監控系統發送警示，以確保訊息不遺失。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q021",
    "職位": "後端工程師",
    "題目": "使用 Scrapy 或 BeautifulSoup 時，遇到 JavaScript 的程式碼要怎麼抓？",
    "類型": "專業題",
    "關鍵詞": ["爬蟲", "Scrapy", "BeautifulSoup", "JavaScript", "Selenium"],
    "標準答案": "因 Scrapy 與 BeautifulSoup 無法執行 JavaScript，可改用 Selenium 或 Playwright 模擬瀏覽器，或觀察 API 請求進行直接擷取。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q022",
    "職位": "後端工程師",
    "題目": "在 git 中 rebase 和 merge 的差異？",
    "類型": "專業題",
    "關鍵詞": ["Git", "rebase", "merge", "版本控制"],
    "標準答案": "merge 將兩分支的歷史合併保留，rebase 則是重新套用 commit，讓歷史更線性清晰；rebase 適合整理 commit，merge 適合保留歷史。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q023",
    "職位": "後端工程師",
    "題目": "在使用 git merge 時，遇到衝突怎麼辦？",
    "類型": "專業題",
    "關鍵詞": ["Git", "merge", "conflict", "衝突處理"],
    "標準答案": "需手動編輯衝突檔案，確認保留版本後，使用 `git add` 標記已解決，再執行 `git commit` 完成合併。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q024",
    "職位": "後端工程師",
    "題目": "在 git 中，什麼是 reset？何時使用？",
    "類型": "專業題",
    "關鍵詞": ["Git", "reset", "HEAD", "版本回退"],
    "標準答案": "`git reset` 是用來回退版本的指令，可改變 HEAD 指向，常見用法如 `--soft`、`--mixed`、`--hard`，依需求選擇回退範圍。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q025",
    "職位": "後端工程師",
    "題目": "PostgreSQL 和 SQLite 的差別？",
    "類型": "專業題",
    "關鍵詞": ["Database", "PostgreSQL", "SQLite", "差異"],
    "標準答案": "PostgreSQL 是完整功能的關聯式資料庫，適用大型專案；SQLite 為輕量型資料庫，適用嵌入式或小型應用。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q026",
    "職位": "後端工程師",
    "題目": "在資料庫應用上，如果資料量太長怎麼處理？",
    "類型": "專業題",
    "關鍵詞": ["Database", "資料優化", "分頁", "分表", "索引"],
    "標準答案": "可透過加索引、分頁查詢、資料分表、分區表、或批次處理等方式來優化大資料量的查詢與寫入效率。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q027",
    "職位": "後端工程師",
    "題目": "在 SQL 中，什麼是 stored procedure？",
    "類型": "專業題",
    "關鍵詞": ["SQL", "Stored Procedure", "預儲程序", "資料庫邏輯"],
    "標準答案": "Stored procedure 是預先儲存在資料庫中的一組 SQL 指令，可重複執行，提高效率並降低應用層與資料庫的交互次數。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q028",
    "職位": "後端工程師",
    "題目": "Raw SQL 和 ORM 的差異？",
    "類型": "專業題",
    "關鍵詞": ["SQL", "ORM", "原生查詢", "抽象層"],
    "標準答案": "Raw SQL 提供直接控制與高效查詢能力；ORM 提供抽象化操作資料庫的方式，易於維護但效能略低。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q029",
    "職位": "後端工程師",
    "題目": "什麼是 Lock concept？",
    "類型": "專業題",
    "關鍵詞": ["資料庫", "Lock", "鎖", "交易一致性"],
    "標準答案": "Lock 是為了保證交易一致性與資料正確性，避免多個交易同時修改同筆資料，常見有共享鎖（S）與排他鎖（X）。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q030",
    "職位": "後端工程師",
    "題目": "請舉例 Amazon SQS 的使用場景？",
    "類型": "專業題",
    "關鍵詞": ["Amazon SQS", "佇列服務", "非同步", "解耦合"],
    "標準答案": "Amazon SQS 適合用於微服務間解耦、非同步任務排程、背景處理等情境，例如：訂單處理、影像轉檔排程。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q031",
    "職位": "後端工程師",
    "題目": "請簡述使用過的雲端服務與其使用場景？",
    "類型": "專業題",
    "關鍵詞": ["雲端服務", "AWS", "GCP", "Azure", "應用案例"],
    "標準答案": "常見雲端服務如 AWS EC2（部署）、S3（儲存）、RDS（資料庫）、Lambda（事件處理）；可依服務特性選擇對應場景使用。",
    "難度": "中",
    "是否需履歷依據": true,
    "履歷條件": "需提及使用過的雲端平台與服務（如 AWS S3、Lambda、EC2 等）"
  },
  {
    "id": "Q032",
    "職位": "後端工程師",
    "題目": "ORM 是什麼？ORM 的優缺點是什麼？",
    "類型": "專業題",
    "關鍵詞": ["ORM", "資料庫", "抽象層", "優缺點"],
    "標準答案": "ORM 是物件關聯對應工具，可讓開發者用程式語言操作資料庫。優點是開發快速、可維護性高；缺點是效能可能不如原生 SQL。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q033",
    "職位": "後端工程師",
    "題目": "請解釋 CAP 定律 或是 ACID 原則。",
    "類型": "專業題",
    "關鍵詞": ["CAP", "ACID", "資料庫", "交易一致性"],
    "標準答案": "CAP 表示一致性、可用性、分區容錯性三者不可兼得；ACID 表示交易需具備原子性、一致性、隔離性、持久性。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q034",
    "職位": "後端工程師",
    "題目": "請解釋關聯式資料庫和非關聯式資料庫的差異。",
    "類型": "專業題",
    "關鍵詞": ["關聯式資料庫", "NoSQL", "資料模型", "儲存結構"],
    "標準答案": "關聯式資料庫使用表格與固定 schema；非關聯式資料庫如 MongoDB 使用文件、Key-Value 等彈性結構，適合快速變動資料。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q035",
    "職位": "後端工程師",
    "題目": "請解釋 Redis 適用的使用情境。",
    "類型": "專業題",
    "關鍵詞": ["Redis", "快取", "非同步任務", "高效能應用"],
    "標準答案": "Redis 適用於快取資料、Session 儲存、佇列管理、排行榜等需要高效讀寫與低延遲的場景。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q036",
    "職位": "後端工程師",
    "題目": "什麼是資料庫正規化？什麼情況要使用反正規化？",
    "類型": "專業題",
    "關鍵詞": ["正規化", "反正規化", "資料冗餘", "查詢效能"],
    "標準答案": "正規化是消除資料冗餘與依賴的過程；反正規化則為提升查詢效能而故意保留冗餘資料，常用於報表或高頻查詢欄位。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q037",
    "職位": "後端工程師",
    "題目": "什麼是 composite index？",
    "類型": "專業題",
    "關鍵詞": ["複合索引", "index", "資料庫查詢", "效能優化"],
    "標準答案": "Composite index 是由多個欄位組成的索引，適用於多欄位條件查詢時可顯著提升效能，但需注意欄位順序影響。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q038",
    "職位": "後端工程師",
    "題目": "如果要用 MongoDB 記錄一個人的點擊 log，你會怎麼設計？",
    "類型": "設計題",
    "關鍵詞": ["MongoDB", "Schema 設計", "log 紀錄", "非關聯式"],
    "標準答案": "可將 user_id 作為主鍵，嵌入 clicks 陣列紀錄每次點擊時間與頁面資訊，或每筆 click 作為一文件分開儲存以利查詢與擴充。",
    "難度": "較難",
    "是否需履歷依據": true,
    "履歷條件": "需具備 MongoDB 使用經驗"
  },
  {
    "id": "Q039",
    "職位": "後端工程師",
    "題目": "假設今天有一模一樣的 query，前幾天只要 500ms 就能跑完，今天突然要 5s 才跑完，你會怎麼解決這個問題？",
    "類型": "情境題",
    "關鍵詞": ["效能診斷", "SQL", "慢查詢", "分析工具"],
    "標準答案": "先檢查資料量、索引是否失效、執行計劃有無改變，使用 EXPLAIN 或監控工具找出瓶頸，必要時考慮 cache 或資料重組。",
    "難度": "較難",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q040",
    "職位": "後端工程師",
    "題目": "某生產環境，有 node.js 一台、DB 一個，尖峰時刻請求都卡在 DB，請問短期、長期各有什麼策略？",
    "類型": "情境題",
    "關鍵詞": ["效能瓶頸", "Node.js", "資料庫", "擴充策略"],
    "標準答案": "短期可增加 cache、調整查詢、加索引；長期應考慮資料分片、讀寫分離、DB 擴充與負載均衡。",
    "難度": "較難",
    "是否需履歷依據": true,
    "履歷條件": "需具備系統效能調校經驗"
  },
  {
    "id": "Q041",
    "職位": "後端工程師",
    "題目": "解釋 JavaScript 的 event loop。",
    "類型": "專業題",
    "關鍵詞": ["JavaScript", "event loop", "非同步", "執行序"],
    "標準答案": "event loop 是 JavaScript 非同步運作核心，透過 call stack 與 message queue 管理同步與非同步任務的執行順序。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q042",
    "職位": "後端工程師",
    "題目": "什麼是 Node.js 錯誤優先的回調函數？",
    "類型": "專業題",
    "關鍵詞": ["Node.js", "callback", "錯誤優先", "非同步"],
    "標準答案": "Node.js 的 callback 通常第一個參數為錯誤物件，若無錯則為 null，這種設計稱為 error-first callback，便於錯誤處理。",
    "難度": "簡單",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q043",
    "職位": "後端工程師",
    "題目": "JWT 和 Session 的差異是什麼？",
    "類型": "專業題",
    "關鍵詞": ["JWT", "Session", "身份驗證", "Token"],
    "標準答案": "Session 通常需由伺服器儲存狀態；JWT 為自包含 token，無需伺服器儲存，適合分散式系統。但 JWT 無法撤銷，有安全風險。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q044",
    "職位": "後端工程師",
    "題目": "你有用過 Git Flow 嗎？",
    "類型": "協作題",
    "關鍵詞": ["Git Flow", "版本管理", "協作流程"],
    "標準答案": "Git Flow 是一種分支管理流程，常包含 develop、feature、release、hotfix 等分支角色，能幫助團隊協作清楚管理開發階段。",
    "難度": "簡單",
    "是否需履歷依據": true,
    "履歷條件": "需曾參與團隊版本協作流程"
  },
  {
    "id": "Q045",
    "職位": "後端工程師",
    "題目": "你認為怎麼樣算是好 code？",
    "類型": "開放題",
    "關鍵詞": ["程式碼品質", "可讀性", "可維護性"],
    "標準答案": "好程式碼應該具有清晰結構、良好命名、低耦合高內聚、容易維護與擴充，並考慮效能與測試。",
    "難度": "簡單",
    "是否需履歷依據": true,
    "履歷條件": "曾參與團隊開發或撰寫多人維護專案"
  },
  {
    "id": "Q046",
    "職位": "後端工程師",
    "題目": "你平常怎麼確保程式碼的可讀性和維護性？",
    "類型": "開放題",
    "關鍵詞": ["程式設計", "可讀性", "維護", "review"],
    "標準答案": "透過一致的程式風格、模組化設計、單一職責原則、撰寫註解與單元測試，並搭配 code review 保持品質。",
    "難度": "中",
    "是否需履歷依據": true,
    "履歷條件": "有參與多人協作或 code review 經驗"
  },
  {
    "id": "Q047",
    "職位": "後端工程師",
    "題目": "程式碼時間和空間的取捨，可以舉個例嗎？",
    "類型": "開放題",
    "關鍵詞": ["效能", "記憶體", "CPU", "trade-off"],
    "標準答案": "例如為了加快查詢速度可使用 cache（佔用記憶體換取時間）；或為了減少記憶體佔用改成 streaming 處理。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q048",
    "職位": "後端工程師",
    "題目": "某網站需要有多個前後台角色且各自有不同權限，請設計 API 與資料庫。",
    "類型": "設計題",
    "關鍵詞": ["API 設計", "RBAC", "權限管理", "資料庫"],
    "標準答案": "可設計 roles、permissions、user_role 三表，搭配 middleware 做角色驗證。API 可依角色回傳不同權限或頁面資料。",
    "難度": "較難",
    "是否需履歷依據": true,
    "履歷條件": "需具備 RBAC 或多角色後台設計經驗"
  },
  {
    "id": "Q049",
    "職位": "後端工程師",
    "題目": "電商網站賣家需要一個可以指定未來時間上架的功能，請設計 API 與資料庫。",
    "類型": "設計題",
    "關鍵詞": ["排程", "API", "電商", "非同步任務"],
    "標準答案": "資料庫加入 scheduled_at 欄位；系統可透過 cron job / queue worker 定時檢查並自動變更狀態。",
    "難度": "中",
    "是否需履歷依據": true,
    "履歷條件": "具備任務排程或自動上架功能設計經驗"
  },
  {
    "id": "Q050",
    "職位": "後端工程師",
    "題目": "電商網站需要能夠顯示前十名賣得最好的商品，請設計 API 與資料庫。如果前端今天不需要即時更新名單，可以怎麼做？",
    "類型": "設計題",
    "關鍵詞": ["排行榜", "統計資料", "快取", "電商 API"],
    "標準答案": "可透過訂單資料聚合出商品銷量，儲存在快取中定時更新（如每小時計算一次），減少查詢負擔。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q051",
    "職位": "後端工程師",
    "題目": "畫出並描述轉帳功能的流程，Server、DB、銀行 API 各自需要做什麼檢查邏輯與例外處理？",
    "類型": "系統設計題",
    "關鍵詞": ["轉帳流程", "驗證", "交易一致性", "銀行 API"],
    "標準答案": "Server 驗證身分與帳戶餘額，DB 寫入交易記錄與鎖定帳戶，與銀行 API 溝通確認交易狀態，並處理超時、失敗與補償。",
    "難度": "困難",
    "是否需履歷依據": true,
    "履歷條件": "需參與過金流或跨系統交易功能設計"
  },
  {
    "id": "Q052",
    "職位": "後端工程師",
    "題目": "什麼是 Microservice 架構？",
    "類型": "系統題",
    "關鍵詞": ["Microservice", "架構設計", "可維護性", "模組化"],
    "標準答案": "Microservice 是將系統拆成小型服務，各自部署與維護，優點是彈性高、擴充性佳，缺點是管理與溝通成本提高。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q053",
    "職位": "後端工程師",
    "題目": "什麼是 Functional Programming？簡單解釋你的理解。",
    "類型": "概念題",
    "關鍵詞": ["Functional Programming", "純函數", "不可變"],
    "標準答案": "Functional Programming 強調使用純函數、不可變資料、函數組合來進行邏輯處理，提升可預測性與測試性。",
    "難度": "中",
    "是否需履歷依據": false,
    "履歷條件": null
  },
  {
    "id": "Q054",
    "職位": "後端工程師",
    "題目": "SPA 和 SSR 技術上有什麼不同？你偏好哪個？為什麼？",
    "類型": "專業題",
    "關鍵詞": ["SPA", "SSR", "渲染", "前後端整合"],
    "標準答案": "SPA 在前端執行渲染，SSR 由伺服器渲染頁面再傳送給用戶。SPA 較快但 SEO 差，SSR 較重但首屏更快。",
    "難度": "中",
    "是否需履歷依據": true,
    "履歷條件": "具備前後端整合開發經驗"
  },
  {
    "id": "Q055",
    "職位": "後端工程師",
    "題目": "描述一下你的專案用了什麼技術、遇到什麼困難、怎麼解決？",
    "類型": "開放題",
    "關鍵詞": ["專案經驗", "技術應用", "問題解決"],
    "標準答案": "建議說明一項具代表性的專案，描述使用的技術（如 DB、框架、API），問題來源（效能、架構、協作）與實際解法。",
    "難度": "中",
    "是否需履歷依據": true,
    "履歷條件": "請提供專案實例與實作角色"
  }
]
